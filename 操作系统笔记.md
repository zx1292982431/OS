# 第五章 虚拟存储器

## 5.1 虚拟存储器概述

#### 常规存储器管理方式的特征和局部性原理

1. 常规存储器管理方式的特征
   * 一次性
   * 驻留性

2. 局部性原理

   程序在执行时将呈现出局部性规律，即在一较短时间内，程序的执行仅局限于某个部分，相应地它访问的存储空间也局限于某个区域

   局限性又表现在下述两个方面：

   1. 时间局限性：如果程序中某数据被访问过，不久后可能再次被访问，产生的典型原因是程序中存在大量循环操作
   2. 空间局限性：程序在一段时间内访问的地址可能集中在一定范围内，典型情况是程序的顺序执行

3. 虚拟存储器的基本工作情况

   将程序当前需要运行的少数页（段）装入内存，其余暂存在盘上，程序在运行时，若需要访问的页（段）已在内存中，程序继续执行，若不在内存中，发出缺页（段）终端，OS利用请求调页（段）功能将它们掉入内存，若此时内存已满，OS利用页（段）的置换功能，将内存中暂时不用的页（段）调至盘中。从而使大程序在小空间中运行。

#### 虚拟存储器的定义和特征

1. 虚拟存储器的定义

   指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统

2. 虚拟存储器的特征

   * 多次性 ——虚拟存储器最重要的特征，是其它存储器管理系统不具备的

   * 对换性——提高内存利用率，由于此特征虚拟存储器才得以正常运行

   * 虚拟性——从逻辑上扩充内存容量，虚拟存储器所表现出来的最重要的特征，实现虚拟存储器的最重要的目标

     ___虚拟性是以多次性和对换性为基础的，多次性和对换性必须建立在离散分配的基础上___

3. 虚拟存储器的实现方法

   所有的虚拟存储器都是采用下述方式之一实现的

   1. 分页请求系统

      分页请求系统是在分页系统的基础上增加请求调页功能和页面置换功能所形成的页式虚拟存储系统

      硬件支持：

      * 请求分页的页表机制
      * 页表中断机构
      * 地址变换机构

      实现请求分页的软件：

      * 请求调页的软件
      * 实现页面置换的软件

     2. 请求分段系统

        请求分段系统是在分段系统的基础上，增加了请求调段和分段置换功能实现的段式虚拟存储系统

        硬件支持：

        * 请求分段的页表机制
        * 段表中断机构
        * 地址变换机构

        实现请求分页的软件：

        * 请求调段的软件
        * 实现段置换的软件

## 5.2 请求分页存储管理方式

请求分页系统建立在分页系统基础上，每次掉入换出的基本单位都是长度固定的页面，因此实现起来要比请求分段系统简单（后者换入换出的是长度可变的段），因此，请求分页是目前最常用的一种实现虚拟存储器的方式

	#### 请求分页中的硬件支持

1. 请求页表机制

​	｜ 页号 ｜ 物理块号 ｜ 状态位P ｜ 访问字段A ｜ 修改位M ｜ 外存地址 ｜

* 状态位P：即存在位，标记页面是否已调入内存，程序访问时参考

* 访问字段A：该页被访问的次数或微被访问的时间，选择换出页面时参考
* 修改位M：用来标记页面被调入内存后是否被修改，由于所有页面在外存中有备份，在置换该页时，若未被修改直接删除，若被修改需更新外存上的备份，在置换页面时参考
* 外存地址：调入时参考

2. 缺页中断机构

   缺页中断是一种特殊的中断，和一般中断有明显区别：

   * 在指令执行期间产生和处理中断信号：通常CPU在一条指令执行完成后检查是否有中断请求到达，但缺页中断是在指令执行期间检查和处理中断信号，以便能及时将所缺页面调入内存
   * 一条指令执行期间可产生多次缺页中断，下图指令设计六次缺页中断（课本P158图5-1）

   ![Screen Shot 2022-05-17 at 11.46.57](/Users/admin/Library/Application Support/typora-user-images/Screen Shot 2022-05-17 at 11.46.57.png)

3. 地址变换机构

   下图为请求分页系统中的地址变换过程（课本P158图5-2）

   ![Screen Shot 2022-05-17 at 11.52.14](/Users/admin/Library/Application Support/typora-user-images/Screen Shot 2022-05-17 at 11.52.14.png)

#### 请求分页中的内存分配

1. 最小物理块数的确定

   最小物理块是指能保证进程正常进行所需最小物理块数

2. 内存分配策略

   在请求分页系统中，可采取两种内存分配策略，固定和可变分配策略，在进行置换时，也可以采取两种策略，全局置换和局部置换，于是组合出以下三种适用的策略

   * 固定分配局部置换：为进程分配固定数目的物理块，在运行期间不改变，若在运行过程中发现缺页，则在分配给该进程的页面中选出一个换出，再调入一页
   * 可变分配全局置换：先为进程分配一定数目的物理块，在程序运行期间可根据情况增加或减少，在进程运行过程中若发现缺页，则将OS保留的空闲物理块取出一块分配给进程，将所缺页调入。
   * 可变分配局部置换：先为进程分配一定数量的物理块，进程运行时发生缺页，在该进程的内存页面中选择一页换出，若进程运行中频繁发生缺页中断，则为其分配附加的物理块，反之，进程运行过程中的缺页率特别低，需适当减少分配给该进程的物理块

3. 物理块分配算法

   * 平均分配算法：系统中可供分配的物理块平均分配给各个进程
   * 按比例分配算法：根据进程的大小按比例分配物理块，若系统中共有n个进程，没个进程的页面数为$S_{i}$，则系统中各页面数总和为$S=\sum_{i=0}^nS_i$又开定系统中可用的物理块为$m$，则没个进程能分到的物理块数$b_i$为：$b_i=\frac{S_i}{S}*m$
   * 考虑优先权的分配算法：把内存中可供分配的物理块分成两部分，一部分按比例分配，另一部分根据进程的优先权进行分配

#### 页面调入策略

1. 何时调入页面
   * 预调页策略：采用某种侧露预计在不久之后便会被访问的页面预先掉入内存
   * 请求调页策略：发现缺页再提出调入请求

2. 从何处调入

   将请求分页系统中的外存分为两部分：文件区和对换区，对换区采用连续内存分配方式，文件去采用离散内存分配方式。

   * 系统拥有足够对换区空间时，全部从对换区调入所需页面
   * 对换区空间不足时，不需要修改的直接从文件区调入，换出时，可能会被修改的，要调到对换区，需要时从对换区调入
   * UNIX方式

3. 页面调入过程

   若发生缺页中断，查找页表找到该页所在物理块，若内存能够容纳新页直接掉入内存，修改页表，若不能容纳，需要从内存中选出一页准备换出，若修改位为1，写回磁盘，若为0直接调出，再将所缺页掉入内存，修改页表，存在位置1，并将该页表写入快表。

4. 缺页率

   假设进程与行过程中，访问页面成功的次数为S，访问页面失败的次数为F，则该进程总的访问页面次数为A=S+F，那么进程运行时的缺页率为$f=\frac{F}{A}$

   通常缺页率受以下因素影响：

   * 页面大小：页面越大缺页率越低

   * 进程分配物理块的数目：分配的物理块越多，缺页率越低

   * 页面置换算法：缺页率是衡量页面置换算法优劣的重要指标

   * 程序固有特性

     ***缺页中断处理时间的计算公式为：***
     $$
     t=\beta*t_a+(1-\beta)*t_b
     $$
     其中$t_a$为被置换页面被修改的缺页中断处理时间，$t_b$为未被修改的缺页中断处理时间，$\beta$为被置换页面被修改的概率

## 5.3 页面置换算法

 ***本笔记中只记录了 最佳置换算法（OPT）、先进先出页面置换算法（FIFO）、最近最久未使用置换算法（LRU）、最少使用置换算法（LFU）***

在进程运行过程中，若其访问的页面不存在，需要将所需页调入内存，但内存无空闲空间时，为了保证进程正常运行，系统必须从内存中调出一页送到磁盘的对换区中。通常把选择换出页面的算法称为页面置换算法。置换算法的好坏将直接影响系统的性能。

不适当的算法会导致进程发生“抖动”

频繁地更换页面，以至一个进程在运行中把大部分时间都花费在页面的置换工作上，我们称该进程发生了“抖动”

#### 最佳置换算法（Optimal）

***最佳置换算法是一种理想化的算法，是不可能实现的***

最佳置换算法选择的被淘汰页是以后永不使用或未来最长时间不会被访问的页面，采用最佳置换算法可保证获得最低的缺页率。

*例：*假定系统为某个进程分配了三个物理块，并考虑由以下的页面号引用串：

7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1

进程运行时，先将7，0，1三个页面装入内存，以后在访问页面2时会产生缺页中断，此时OS根据最佳页面置换算法将选择页面7予以淘汰。因为7是未来最长时间不会被访问的页面。整个过程如下图（课本P163图5-3），共发生6次页面置换。

![Screen Shot 2022-05-17 at 20.49.21](/Users/admin/Library/Application Support/typora-user-images/Screen Shot 2022-05-17 at 20.49.21.png)

#### 先进先出页面置换算法（FIFO）

先进先出页面置换算法总是淘汰最先进入内存的页面，即选择在内存中驻留最久的页面予以淘汰。该算法不能保证经常访问的页面不被淘汰，因此可能效果较差。仍采用上面的例子，FIFO算法进行了12次页面置换，过程见下图（P164图5-4）![Screen Shot 2022-05-17 at 20.54.04](/Users/admin/Library/Application Support/typora-user-images/Screen Shot 2022-05-17 at 20.54.04.png)

#### 最近最久未使用置换算法（LRU）

LRU置换算法选择最近最久未使用的页面予以淘汰。该算法赋予每个页面一个访问字段，用来记录一个页面自上一次本访问以来所经历的时间t，当余姚淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面予以淘汰，下图仍是上例采用LRU置换算法的过程，进行了9次页面置换。![Screen Shot 2022-05-17 at 21.10.51](/Users/admin/Library/Application Support/typora-user-images/Screen Shot 2022-05-17 at 21.10.51.png)

LRU置换算法需有寄存器和栈两类硬件之一的支持：

* 移位寄存器法：为在内存中的每个页面配置一个移位寄存器，表示为$R=R_{n-1}R_{n-2}R_{n-3}\dots R_2R_1R_0$，当进程访问某物理块时，将该物理块对应寄存器的$R_{n-1}$位赋值为1，每隔一段时间将寄存器右移一位，把n位寄存器看作一个整数，那么拥有最小数值的寄存器所对应的页面就是最近最久未使用的页面，如下图（P165图5-6）中第三个页面的R值最小，发生缺页时页面3将被置换出去![Screen Shot 2022-05-17 at 21.21.45](/Users/admin/Library/Application Support/typora-user-images/Screen Shot 2022-05-17 at 21.21.45.png)

* 访问页堆栈法：可以用一个栈来存放当前使用各个页面的页号，当进程访问某个页面时，便将该页面的页号从对战中移出并压入栈顶，这样一来，栈顶始终是最新被访问的页面页号，栈低的页号就是最近最久未使用页面的页号。

  *例：*现回定一进程分有5个物理块，访问页面的页号序列为：

  4，7，0，7，1，0，1，2，1，2，6

  栈的变化过程如下图（P165图5-7），在第11次访问页面6时发生缺页，此时页面4时最近最久未使用的页

![Screen Shot 2022-05-17 at 21.27.41](/Users/admin/Library/Application Support/typora-user-images/Screen Shot 2022-05-17 at 21.27.41.png)

#### 最少使用置换算法（LFU）

最少使用置换算法选择在最近时期是用最少的页面作为淘汰页

在最少使用置换算法中页采用了移位寄存器，每次访问某页时，便将该页所对应的移位寄存器的最高位置为1，再每隔一段时间右移一次。这样一来，在一段时间内使用最少的页面将时$\sum{R_i}$最小的项。LFU置换算法的页面访问图，与LRU置换算法的访问图完全相同。

***但要注意，上述算法并不能真正反映出页面的使用情况，因为在每一时间间隔内，只是用寄存器的移位来记录页的使用情况，因此在该时间间隔内，对某页访问1次和访问1000次是完全等效的***

#### 访问内存的有效时间

$$
ETA=\lambda+a*t+(1-a)*[t+f*(\epsilon+\lambda+t)+(1-f)*(\lambda+t)]
$$

其中，a为快表的命中率，f为缺页率，$\lambda$为查找快表的时间，$\epsilon$为缺页中断的处理时间，t为查找页表或访问实际物理地址所需要的时间

对上式的解释如下：

访问内存的有效时间=快表的查询时间+命中率\*命中情况下的访问时间+(1-命中率)\*未命中情况下的查询时间

命中情况下的查询时间=命中率*访问实际物理地址的时间

未命中情况下的查询时间=查找页表的时间+缺页率\*发生缺页中断情况下的访问时间+(1-缺页率)\*未发生缺页中断情况下的访问时间

发生缺页中断情况下的访问时间=缺页中断处理时间+写入快表的时间+访问实际物理地址的时间

未发生缺页中断情况下的访问时间=写入快表的时间+访问实际物理地址的时间

## 5.4 “抖动”与工作集

#### 多道程序度与“抖动”

随着进程数目的增加，处理机的利用率先急剧升高，后缓慢下降，见下图（P170图5-9）![Screen Shot 2022-05-17 at 22.53.36](/Users/admin/Library/Application Support/typora-user-images/Screen Shot 2022-05-17 at 22.53.36.png)

产生上图所描述情况的原因是系统中发生了“抖动”，发生“抖动”的根本原因是：同时在系统中运行的进程太多，由此分配给每一个进程的物理块太少，不能满足进程正常运行的基本要求，致使进程在运行时频繁进行页面的置换，造成进程的大部分时间都用于页面的置换，而几乎不能进行有效的工作，从而导致处理机利用率下降。

#### 工作集

工作集的引入：进程发生缺页率的时间间隔与进程所获的的物理块数有关，关系见下图（P171图5-10）由图可见，当物理块数超过某个数目时，再为进程增加一物理块，对缺页率的改善已不明显，反之，但某进程所分配的物理块低于某个数目时，每减少一块，对缺页率产生的影响都十分明显。![Screen Shot 2022-05-17 at 23.08.38](/Users/admin/Library/Application Support/typora-user-images/Screen Shot 2022-05-17 at 23.08.38.png)

如果能预知程序在某段时间间隔内要访问那些页面，并将它们掉入内存，会大大降低缺页率，从而显著提高处理机利用效率

工作集定义：工作集是指在某段时间间隔$\Delta$里进程世纪要访问的页面集合，把某进程在时间t的工作集记为$w(t,\Delta)$，其中的变量$\Delta$称为工作集的“窗口尺寸”，也就是说，工作集时进程在时间间隔$(t-\Delta,t)$中引用页面的集合。

工作集满足：$w(t,\Delta)\subseteq w(t,\Delta+1)$

#### 抖动的预防方法

* 采用局部置换策略：若页面分配和置换策略中，若采取可变分配策略，可采取局部置换策略预防发生“抖动”，就算某进程发生抖动，也不会对其它进程产生影响，从而把“抖动”的影响限制在较小范围内
* 把工作集算法融入到处理机调度中：当处理机利用率低下时，他将试图从外存调入一个新作业进入内存
* 利用“L=S”准则调节缺页率：L时缺页之间的平均时间，S时平均缺页服务时间，即用于置换一个页面所需要的时间，如果L远比S大，说明很少发生缺页，未充分利用磁盘能力，反之，若L比S小，说明频繁发生缺页，缺页速度已经超过磁盘的处理能力，只有L与S接近时，磁盘和处理机才都大到最大利用率。
* 选择暂停的进程：即减少多道程序的数目

## 5.5 请求分段存储管理方式

请求分段存储管理方式是以段为单位进行换入、换出的，其与请求分页存储管理方式在实现原理以及硬件支持上都十分相似

#### 请求分段中的硬件支持

1. 请求段表机制

   请求分段式管理中所需要的主要数据结构式请求段表，结构如下：

   ｜段名｜段长｜段基址｜存取方式｜访问字段A｜修改位M｜存在位P｜增补位｜外存始址｜

   * 存取方式：由于应用程序中的段式逻辑单位，可根据该信息的属性对它实施保护，存取属性包括：只执行、只读、允许读/写

   * 缺段中断机构：缺段中断处理过程如下图（P174图5-12）

     ![Screen Shot 2022-05-18 at 01.22.32](/Users/admin/Library/Application Support/typora-user-images/Screen Shot 2022-05-18 at 01.22.32.png)

   * 地址变换机构：下图（P174图5-13）为请求分段系统的地址变换过程

![Screen Shot 2022-05-18 at 01.27.18](/Users/admin/Library/Application Support/typora-user-images/Screen Shot 2022-05-18 at 01.27.18.png)

#### 分段的保护与共享

·分段存储管理方式的优点是便于实现分段的共享与保护，分段共享所需要的数据结构是**共享段表**

#### 共享段表

共享段表记录了共享段的段号、段长、内存始址、状态（存在）位、外存始址以及共享技术等信息，各项说明如下：

* 共享进程计数count：记录有多少个进程正在共享该分段，在某进程不再需要某段而释放该段时，系统先检查count是否为0，若为0回收该段所占内存区，若不为0，不立即回收该段所占内存区。
* 存取控制字：标记存取权限，如只读、可读写
* 段号

#### 共享段的分配与回收

* 共享段的分配：对第一个请求使用该共享段的进程，由OS为该共享段分配物理分区，再把该段调入分区，在该段总增加一表项，记录请求使用该段寄存合格进程名、段号、存取权限等数据，把count置为1，当又有其它进程请求该段时，将有关信息写入表中，counte++；
* 共享段的回收：当某进程不需要某个共享段时，将该段释放，撤销该进程段表中共享段所对应的表项，执行count--，若结果为0，回收由该共享段占用的物理内存，若不为0，只是取消调用者进程在共享段表中的有关记录。
* 分段保护
  * 越界检查：由地址变换机构完成，越界将产生越界中断
  * 存取控制检查
  * 环保护机构：该机制中规定，低编号的环具有高优先权，OS核心处于0号环内；某些重要的实用程序和操作系统服务占据中间环；一般的应用程序被安排在外环上。在环系统中，程序的访问和调用遵循以下原则，环保护机构中的调用程序和数据访问的关系如下图（P177图5-15）：
    * 一个程序可以访问驻留在相同环或较低特权环（外环）中的数据
    * 一个程序可以调用驻留在相同环或较高特权环（内环）中的服务

![Screen Shot 2022-05-19 at 21.32.19](/Users/admin/Library/Application Support/typora-user-images/Screen Shot 2022-05-19 at 21.32.19.png)

